#include <iostream>
#include <math.h>
#include "conio.h"

using std::cin;
using std::cout;
using std::endl;

typedef struct mystack
{
	char sign='_';
	char op[10]="\0";
	
	mystack* prev = NULL;
}*stp,st;

typedef struct treenode
{
	char value='0';
	char value2[10];
	treenode* right;
	treenode* left;



} *treep ,tree;

typedef struct mytreestack
{
	mytreestack* prev;
	treep node;

}*trstp,trst;

bool checkprecedence(char line[100],int i, stp stackelement)          //change i
{
	int stackvalue = 0;
	int linevalue = 0;

	switch (stackelement->sign)
	{
	case ('-'):
		stackvalue = 1;
		break;
	case ('+'):
		stackvalue = 1;
		break;
	case ('*'):
		stackvalue = 2;
		break;
	case ('/'):
		stackvalue = 2;
		break;
	case ('^'):
		stackvalue = 3;
		break;
	}

	switch (line[i+2])
	{
	case ('-'):
		linevalue = 1;
		break;
	case ('+'):
		linevalue = 1;
		break;
	case ('*'):
		linevalue = 2;
		break;
	case ('/'):
		linevalue = 2;
		break;
	case ('^'):
		linevalue = 3;
		break;
	}
	if (stackvalue - linevalue < 0)
		return false;
	else return true;
}                           //change i                                    

void toppop(stp* stackelement, char rpnline[100],int* j)            //maybe delete *
{
stp* switchtoprev=new stp;  
*switchtoprev = (*stackelement)->prev;

rpnline[*j] = (*stackelement)->sign;
(*j)++;
rpnline[*j] = 32;
(*j)++;
delete (*stackelement);
*stackelement = new st;

if ((*switchtoprev) == NULL)
*stackelement = NULL;
else

	*stackelement = (*switchtoprev);




}

void popornot(stp* stackelement, char rpnline[100], int* j,stp* previous,char line[100],int *i)
{
	
	if ((*stackelement) != NULL && checkprecedence(line, *i, *stackelement))
	{
		toppop(stackelement, rpnline, j);
		if ((*stackelement) == NULL || (*stackelement)->sign == '_')
		{
			(*stackelement) = NULL;
			*previous = NULL;                                                 //maybe delete
		}
		else
			(*previous) = (*stackelement);                       //maybe delete changing previous after changing element
		popornot(stackelement, rpnline, j, previous, line, i);
	}


}

void unloadinbrackets(stp* stackelement, char rpnline[100], int* j)
{
	stp* switchtoprev = new stp;
	
	while ((*stackelement)->sign!='(')
	{
		
		if ((*stackelement) == NULL || (*stackelement)->sign=='(')
			break;
		*switchtoprev = (*stackelement)->prev;
		rpnline[*j] = (*stackelement)->sign;
		(*j)++;
		rpnline[*j] = 32;
		(*j)++;
		delete (*stackelement);
		(*stackelement) = new st;
		(*stackelement) = (*switchtoprev);
		//check 1 + 2 * 4 * 8 * 9 + 5 * 6 + 7

	}
	if ((*stackelement)->sign == '(')
	{
		*switchtoprev = (*stackelement)->prev;
		delete (*stackelement);
		(*stackelement) = new st;
		(*stackelement) = (*switchtoprev);
	}


}

bool isinline(char variables[100], char ch,int j)
{
	
	for (int i = 0; i<j; i++)
	{
		if (ch == variables[i])
			return true;


	}

	return false;
}

void changevariables(char line[100])
{
	char ch='0',ch1='0';
	int j = 0;
	char variables[100];
	
	for (int i = 0; ch != '\0'; i++)
	{
		ch = line[i];
		if (ch == '\0')
			break;
		if (ch == 'l' && line[i + 1] == 'o' && line[i + 2] == 'g')
		{
			i = i + 3;
			ch = line[i];
		}
		if (ch != 32 && (ch > 57 || ch < 48) && ch != 'e' && ch != ',' && ch != '+' && ch != '^' && ch != '*' && ch != '/' && ch != '(' && ch != ')' && ch != '-')
		{
			if (!isinline(variables, ch, j))
			{
				variables[j] = ch;
				j++;
			}


		}


	}
	variables[j] = '\0';
	
	for ( j = 0; variables[j] != '\0'; j++)
	{
			cout << "Enter the value of the " << variables[j] << " variable: " << endl;
			ch = _getch();
			if (cin.fail())
			{
				cin.ignore(cin.rdbuf()->in_avail());
				cin.clear();
			}
			
			for (int i = 0; line[i] != '\0'; i++)
			{
				
				if (line[i] == variables[j])
					line[i] = ch;

			}
	}
	
	cout << "---------------------" << endl;
	cout << line << endl;
}

treep createtree(char rpnline[100]);

void createrpn(char line[100])
{
	stp previous = new st;
	previous = NULL;
	stp stackelement = new st;
	
	stackelement = NULL;
	char rpnline[100];
	char ch='0';
	//char check;                                                //to check binar minus
	int i = 0;
	int j = 0;
	while (ch != '\0')
	{
		ch = line[i];
		if (ch == '\0')
		{
			rpnline[j] = ch;
			break;
		}

		if (ch == 'l' && line[i + 1] == 'o' && line[i + 2] == 'g')      //read log(x,y)
		{
			while (ch != 32 && ch != '\0')
			{
				rpnline[j] = ch;
				j++;
				i++;
				ch = line[i];
			}
			rpnline[j] = 32;
			j++;
		}

		if (ch <= 57 && ch >= 48 || ch=='e')
		{
			rpnline[j] = ch;
			j++;
			rpnline[j] = 32;
			j++;
			
			if (line[i + 1] != '\0' && line[i + 2] != ')')
				popornot(&stackelement, rpnline, &j, &previous, line, &i);           

			else if (line[i + 2] == ')')                                            //operation for closed brackets;
			{                                                                       //mayve put in loop while (line[i + 2] == ')')
				while (line[i + 2] == ')')
				{
					unloadinbrackets(&stackelement, rpnline, &j);
					i = i + 2;
				}
				if (line[i + 1] != '\0' && line[i + 2] != ')')
				popornot(&stackelement, rpnline, &j, &previous, line, &i);
			}                                                                 

			if (stackelement!= NULL && stackelement->sign == '_')
			{
				stackelement = NULL;
				previous = NULL;                                                 
			}
			
		}


		if ( ch == '+' || ch == '^' || ch == '*' || ch == '/' || ch=='(')            //check minus
		{       
			previous = stackelement;                                           //maybe delete this previous
			if (stackelement == NULL)
				delete stackelement;
			stackelement = new st;
			stackelement->sign = ch;
			stackelement->prev = previous;
			previous = stackelement;
		}

		if (ch == '-' && line[i + 1] == 32)
		{
			if (stackelement == NULL)                                  //maybe delete
				delete stackelement;
			stackelement = new st;
			stackelement->sign = ch;
			stackelement->prev = previous;
			previous = stackelement;
		}

		else if(ch == '-' && line[i + 1] != 32)
		{

			rpnline[j] = ch;
			j++;
			rpnline[j] = line[i + 1];
			j++;
			i++;

		}

	   
		i++;
		
	}
	while (stackelement != NULL)
	{
		if (stackelement == NULL)
			break;
		rpnline[j] = stackelement->sign;
		j++;
		rpnline[j] = 32;
		j++;
		stackelement = stackelement->prev;
		//check 1 + 2 * 4 * 8 * 9 + 5 * 6 + 7

	}
	j--;
	rpnline[j] = '\0';
	cout << rpnline << endl;

	treep treenode;
	treenode = createtree(rpnline);
}

void pushtreestack(trstp* treestackelement, trstp* previous, treep* treenode)
{
	(*previous) = (*treestackelement);
	(*treestackelement) = new trst;
	
	(*treestackelement)->node = (*treenode);
	(*treestackelement)->prev = (*previous);

}

treep createtree(char rpnline[100])
{
	trstp treestackelement = new trst;
	treestackelement = NULL;
	trstp previous = new trst;
	previous = NULL;
	treep treenode;

	treep pop1;
	treep pop2;

	char ch;

	for (int i = 0; rpnline[i] != '\0'; i++)
	{
		ch = rpnline[i]; 

		if (ch == 'l' && rpnline[i + 1] == 'o' && rpnline[i + 2] == 'g')      //read log(x,y)
		{
			treenode = new tree;
			int j = 0;
			while (ch != 32 && ch != '\0')
			{
				treenode->value2[j] = ch;
				i++;
				j++;
				ch = rpnline[i];
			}
			treenode->value2[j] = '\0';
			treenode->left = NULL;
			treenode->right = NULL;
			pushtreestack(&treestackelement, &previous, &treenode);
		}

		if (ch <= 57 && ch >= 48 || ch == 'e')
		{
			treenode = new tree;
			treenode->value = ch;
			treenode->left = NULL;
			treenode->right = NULL;

			pushtreestack(&treestackelement, &previous, &treenode);
		}


		if (ch == '+' || ch == '^' || ch == '*' || ch == '/' || ch == '(')            //check minus
		{
			pop1 = treestackelement->node;
			pop2 = (treestackelement->prev)->node;

			treenode = new tree;

			treenode->left = pop1;
			treenode->right = pop2;
			treenode->value = ch;

			int count = 2;
			while (count)
			{
				previous = treestackelement->prev;
				delete treestackelement;
				treestackelement = new trst;
				treestackelement = previous;
				count--;
			}
			pushtreestack(&treestackelement, &previous, &treenode);
		}

		if (ch == '-' && rpnline[i + 1] == 32)
		{
			pop1 = treestackelement->node;
			pop2 = (treestackelement->prev)->node;

			treenode = new tree;

			treenode->left = pop1;
			treenode->right = pop2;
			treenode->value = ch;

			int count = 2;
			while (count)
			{
				previous = treestackelement->prev;
				delete treestackelement;
				treestackelement = new trst;
				treestackelement = previous;
				count--;
			}
			pushtreestack(&treestackelement, &previous, &treenode);

		}

		else if (ch == '-' && rpnline[i + 1] != 32)
		{
			treenode = new tree;
			int j = 0;
			while (ch != 32 && ch != '\0')
			{
				treenode->value2[j] = ch;
				i++;
				j++;
				ch = rpnline[i];
			}
			treenode->value2[j] = '\0';
			treenode->left = NULL;
			treenode->right = NULL;
			pushtreestack(&treestackelement, &previous, &treenode);
			

		}

	}
	treenode = treestackelement->node;
	return treenode;
}

int main()
{
	char line[100];
	cin.getline(line, 100);
	if (cin.fail())
	{
		cin.ignore(cin.rdbuf()->in_avail());
		cin.clear();
	}
	changevariables(line);
	createrpn(line);
	
	return 0;
}
